# -*- coding: utf-8 -*-
"""
Test VAR Model
"""
import os
import sys
import warnings

from six import BytesIO
from six.moves import range, StringIO

import numpy as np
from numpy.testing import assert_almost_equal, assert_allclose
import pandas as pd
import scipy.linalg
import pytest

import sm2.api as sm
import sm2.tools.data as data_util
import sm2.tsa.vector_ar.util as util
from sm2.tsa.vector_ar.var_model import VAR

cur_dir = os.path.dirname(os.path.abspath(__file__))

have_matplotlib = False
try:
    import matplotlib  # noqa:F401
    have_matplotlib = True
except ImportError:
    pass

_orig_stdout = None


def setup_module():
    global _orig_stdout
    _orig_stdout = sys.stdout
    sys.stdout = StringIO()


def teardown_module():
    sys.stdout = _orig_stdout
    close_plots()


def close_plots():
    try:
        import matplotlib.pyplot as plt
        plt.close('all')
    except ImportError:
        pass


def get_macrodata():
    dataset = sm.datasets.macrodata.load_pandas()
    data = dataset.data[['realgdp', 'realcons', 'realinv']]
    data = data.to_records(index=False)
    nd = data.view((float, 3), type=np.ndarray)
    nd = np.diff(np.log(nd), axis=0)
    return nd.ravel().view(data.dtype, type=np.ndarray)


def get_lutkepohl_data(name='e2'):
    vdir = os.path.split(cur_dir)[0]
    data_dir = os.path.join(vdir, 'data')
    path = os.path.join(data_dir, '%s.dat' % name)
    raise NotImplementedError("parse_lutkepohl_data not ported")
    return util.parse_lutkepohl_data(path)


# TODO: Is this long-defunct?
def generate_var():
    from rpy2.robjects import r
    import pandas.rpy.common as prp
    r.source('tests/var.R')
    return prp.convert_robj(r['result'], use_pandas=False)


# TODO: Is this long-defunct?
def write_generate_var():
    result = generate_var()
    np.savez('tests/results/vars_results.npz', **result)


# ------------------------------------------------------------------------
# Externally Produced Results

class E1_Results(object):
    """Results from LÃ¼tkepohl (2005) using E2 dataset"""
    # Lutkepohl p. 120 results

    # I asked the author about these results and there is probably rounding
    # error in the book, so I adjusted these test results to match what is
    # coming out of the Python (double-checked) calculations
    irf_stderr = np.array([[[.125, 0.546, 0.664],
                            [0.032, 0.139, 0.169],
                            [0.026, 0.112, 0.136]],

                           [[0.129, 0.547, 0.663],
                            [0.032, 0.134, 0.163],
                            [0.026, 0.108, 0.131]],

                           [[0.084, .385, .479],
                            [.016, .079, .095],
                            [.016, .078, .103]]])

    cum_irf_stderr = np.array([[[.125, 0.546, 0.664],
                                [0.032, 0.139, 0.169],
                                [0.026, 0.112, 0.136]],

                               [[0.149, 0.631, 0.764],
                                [0.044, 0.185, 0.224],
                                [0.033, 0.140, 0.169]],

                               [[0.099, .468, .555],
                                [.038, .170, .205],
                                [.033, .150, .185]]])

    lr_stderr = np.array([[.134, .645, .808],
                          [.048, .230, .288],
                          [.043, .208, .260]])


class RResults(object):
    """Simple interface with results generated by "vars" package in R."""
    def __init__(self):
        from .results.results_var_data import var_results
        data = var_results.__dict__

        self.names = data['coefs'].dtype.names
        self.params = data['coefs'].view((float, len(self.names)),
                                         type=np.ndarray)
        self.stderr = data['stderr'].view((float, len(self.names)),
                                          type=np.ndarray)

        self.irf = data['irf'].item()
        self.orth_irf = data['orthirf'].item()

        self.nirfs = int(data['nirfs'][0])
        self.nobs = int(data['obs'][0])
        self.totobs = int(data['totobs'][0])

        crit = data['crit'].item()
        self.aic = crit['aic'][0]
        self.sic = self.bic = crit['sic'][0]
        self.hqic = crit['hqic'][0]
        self.fpe = crit['fpe'][0]

        self.detomega = data['detomega'][0]
        self.loglike = data['loglike'][0]

        self.nahead = int(data['nahead'][0])
        self.ma_rep = data['phis']

        self.causality = data['causality']


# ------------------------------------------------------------------------

@pytest.mark.not_vetted
class CheckIRF(object):
    ref = None
    res = None
    irf = None
    k = None

    def test_irf_coefs(self):
        self._check_irfs(self.irf.irfs, self.ref.irf)

    def test_orth_irf_coefs(self):
        self._check_irfs(self.irf.orth_irfs, self.ref.orth_irf)

    def _check_irfs(self, py_irfs, r_irfs):
        for i, name in enumerate(self.res.names):
            ref_irfs = r_irfs[name].view((float, self.k), type=np.ndarray)
            res_irfs = py_irfs[:, :, i]
            assert_almost_equal(ref_irfs, res_irfs)

    @pytest.mark.smoke
    @pytest.mark.skipif(not have_matplotlib, reason="matplotlib not available")
    def test_plot_irf(self):
        import matplotlib.pyplot as plt
        self.irf.plot()
        plt.close('all')
        self.irf.plot(plot_stderr=False)
        plt.close('all')

        self.irf.plot(impulse=0, response=1)
        plt.close('all')
        self.irf.plot(impulse=0)
        plt.close('all')
        self.irf.plot(response=0)
        plt.close('all')

        self.irf.plot(orth=True)
        plt.close('all')
        self.irf.plot(impulse=0, response=1, orth=True)
        close_plots()

    @pytest.mark.smoke
    @pytest.mark.skipif(not have_matplotlib, reason="matplotlib not available")
    def test_plot_cum_effects(self):
        # I need close after every plot to avoid segfault, see GH#3158
        import matplotlib.pyplot as plt
        plt.close('all')
        self.irf.plot_cum_effects()
        plt.close('all')
        self.irf.plot_cum_effects(plot_stderr=False)
        plt.close('all')
        self.irf.plot_cum_effects(impulse=0, response=1)
        plt.close('all')

        self.irf.plot_cum_effects(orth=True)
        plt.close('all')
        self.irf.plot_cum_effects(impulse=0, response=1, orth=True)
        close_plots()


@pytest.mark.smoke
class CheckFEVD(object):
    # This is considered "vetted" only because it is exclusively smoke-tests
    fevd = None

    @pytest.mark.skipif(not have_matplotlib, reason="matplotlib not available")
    def test_fevd_plot(self):
        self.fevd.plot()
        close_plots()

    def test_fevd_repr(self):
        self.fevd

    def test_fevd_summary(self):
        self.fevd.summary()

    @pytest.mark.xfail(reason="FEVD.cov() not implemented; this test is"
                              "commented-out upstream")
    def test_fevd_cov(self):
        # test does not crash
        # not implemented
        covs = self.fevd.cov()


@pytest.mark.not_vetted
class TestVARResults(CheckIRF, CheckFEVD):
    p = 2

    @classmethod
    def setup_class(cls):
        cls.data = get_macrodata()
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            cls.model = VAR(cls.data)
            cls.res = cls.model.fit(maxlags=cls.p)

        cls.names = cls.model.endog_names
        cls.ref = RResults()
        cls.k = len(cls.ref.names)

        cls.irf = cls.res.irf(cls.ref.nirfs)
        cls.nahead = cls.ref.nahead

        cls.fevd = cls.res.fevd()

    @pytest.mark.smoke
    @pytest.mark.parametrize('attr', ['summary',
                                      '__str__', '__repr__', 'cov_ybar'])
    def test_method(self, attr):
        method = getattr(self.res, attr)
        method()

    @pytest.mark.smoke
    @pytest.mark.parametrize('attr', ['tvalues', 'pvalues', 'cov_params'])
    def test_attr(self, attr):
        # TODO: Make sure we get versions with pandas-wrapping; cov_params
        # in particular
        getattr(self.res, attr)

    @pytest.mark.parametrize('attr', ['detomega', 'params', 'stderr',
                                      'aic', 'bic', 'hqic', 'fpe', 'nobs'])
    def test_attr_value(self, attr):
        # Like `test_attr`, but not just a smoke-test
        # note: upstream checks params with rtol==1e-3 and stderr with 1e-4
        value = getattr(self.res, attr)
        expected = getattr(self.ref, attr)
        assert_almost_equal(value, expected)

    @pytest.mark.smoke
    def test_constructor(self):
        # make sure this works with no names
        ndarr = self.data.view((float, 3), type=np.ndarray)
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            model = VAR(ndarr)
            model.fit(self.p)

    def test_names(self):
        assert self.model.endog_names == list(self.ref.names)
        # TODO: self.ref.names should be a list in the first place

        model2 = VAR(self.data)
        assert model2.endog_names == list(self.ref.names)

    @pytest.mark.skip(reason="get_eq_index not ported from upstream")
    def test_get_eq_index(self):
        assert type(self.res.names) is list

        for i, name in enumerate(self.names):
            idx = self.res.get_eq_index(i)
            idx2 = self.res.get_eq_index(name)

            assert idx == i
            assert idx == idx2

        with pytest.raises(Exception):
            self.res.get_eq_index('foo')

    @pytest.mark.smoke
    def test_lagorder_select(self):
        ics = ['aic', 'fpe', 'hqic', 'bic']
        for ic in ics:
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                self.model.fit(maxlags=10, ic=ic, verbose=True)

    def test_fit_invalid_ic(self):
        with pytest.raises(Exception):
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                self.model.fit(ic='foo')

    def test_loglike(self):
        assert_almost_equal(self.res.llf, self.ref.loglike)

    def test_ma_rep(self):
        ma_rep = self.res.ma_rep(self.nahead)
        assert_almost_equal(ma_rep, self.ref.ma_rep)

    # --------------------------------------------------
    # Lots of tests to make sure stuff works...need to check correctness

    def test_causality(self):
        causedby = self.ref.causality['causedby']

        for i, name in enumerate(self.names):
            variables = self.names[:i] + self.names[i + 1:]
            result = self.res.test_causality(name, variables, kind='f')
            assert_almost_equal(result.pvalue,
                                causedby[i],
                                4)

            rng = list(range(self.k))
            rng.remove(i)
            result2 = self.res.test_causality(i, rng, kind='f')
            assert_allclose(result.pvalue,
                            result2.pvalue,
                            rtol=1e-12)

            # make sure works
            result = self.res.test_causality(name, variables, kind='wald')

        # corner cases
        self.res.test_causality(self.names[0], self.names[1])
        self.res.test_causality(0, 1)

        with pytest.raises(Exception):
            self.res.test_causality(0, 1, kind='foo')

    @pytest.mark.smoke
    def test_select_order(self):
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")

            self.model.fit(10, ic='aic', verbose=True)
            self.model.fit(10, ic='fpe', verbose=True)

            # bug
            model = VAR(self.model.endog)
            model.select_order()

    def test_is_stable(self):
        # may not necessarily be true for other datasets
        assert self.res.is_stable(verbose=True)

    def test_acf(self):
        # test that it works...for now
        acfs = self.res.acf(10)

        # defaults to nlags=lag_order
        acfs = self.res.acf()
        assert len(acfs) == self.p + 1

    @pytest.mark.smoke
    def test_acorr(self):
        self.res.acorr(10)

    @pytest.mark.smoke
    def test_forecast(self):
        self.res.forecast(self.res.y[-5:], 5)

    @pytest.mark.smoke
    def test_forecast_interval(self):
        y = self.res.y[:-self.p:]
        self.res.forecast_interval(y, 5)

    @pytest.mark.smoke
    @pytest.mark.skipif(not have_matplotlib, reason="matplotlib not available")
    def test_plot_sim(self):
        self.res.plotsim(steps=100)
        close_plots()

    @pytest.mark.smoke
    @pytest.mark.skipif(not have_matplotlib, reason="matplotlib not available")
    def test_plot(self):
        self.res.plot()
        close_plots()

    @pytest.mark.smoke
    @pytest.mark.skipif(not have_matplotlib, reason="matplotlib not available")
    def test_plot_acorr(self):
        self.res.plot_acorr()
        close_plots()

    @pytest.mark.smoke
    @pytest.mark.skipif(not have_matplotlib, reason="matplotlib not available")
    def test_plot_forecast(self):
        self.res.plot_forecast(5)
        close_plots()

    def test_reorder(self):
        # manually reorder
        data = self.data.view((float, 3), type=np.ndarray)
        names = self.names
        data2 = np.append(np.append(data[:, 2, None], data[:, 0, None],
                                    axis=1),
                          data[:, 1, None],
                          axis=1)
        names2 = []
        names2.append(names[2])
        names2.append(names[0])
        names2.append(names[1])

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            res2 = VAR(data2).fit(maxlags=self.p)

        # use reorder function
        res3 = self.res.reorder(['realinv', 'realgdp', 'realcons'])

        # check if the main results match
        assert_almost_equal(res2.params, res3.params)
        assert_almost_equal(res2.sigma_u, res3.sigma_u)
        assert_almost_equal(res2.bic, res3.bic)
        assert_almost_equal(res2.stderr, res3.stderr)

    def test_pickle(self):
        fh = BytesIO()
        # test wrapped results load save pickle
        del self.res.model.data.orig_endog
        self.res.save(fh)
        fh.seek(0, 0)
        res_unpickled = self.res.__class__.load(fh)
        assert type(res_unpickled) is type(self.res)
        # TODO: Check something other than type equality?  not very meaningful


@pytest.mark.skip(reason="parse_lutkepohl_data not ported")
@pytest.mark.smoke
def test_lutkepohl_parse():
    files = ['e%d' % i for i in range(1, 7)]
    for f in files:
        get_lutkepohl_data(f)


@pytest.mark.skip(reason="parse_lutkepohl_data not ported")
@pytest.mark.not_vetted
class TestVARResultsLutkepohl(object):
    """
    Verify calculations using results from LÃ¼tkepohl's book
    """
    p = 2

    @classmethod
    def setup_class(cls):
        sdata, dates = get_lutkepohl_data('e1')

        data = data_util.struct_to_ndarray(sdata)
        adj_data = np.diff(np.log(data), axis=0)
        # est = VAR(adj_data, p=2, dates=dates[1:], names=names)

        cls.model = VAR(adj_data[:-16], dates=dates[1:-16], freq='BQ-MAR')
        cls.res = cls.model.fit(maxlags=cls.p)
        cls.irf = cls.res.irf(10)
        cls.lut = E1_Results()

    def test_approx_mse(self):
        # 3.5.18, p. 99
        mse2 = np.array([[25.12, .580, 1.300],
                         [.580, 1.581, .586],
                         [1.300, .586, 1.009]]) * 1e-4

        assert_allclose(mse2, self.res.forecast_cov(3)[1],
                        rtol=1e-3)

    def test_irf_stderr(self):
        irf_stderr = self.irf.stderr(orth=False)
        for i in range(1, 1 + len(self.lut.irf_stderr)):
            assert_almost_equal(np.round(irf_stderr[i], 3),
                                self.lut.irf_stderr[i - 1])

    def test_cum_irf_stderr(self):
        stderr = self.irf.cum_effect_stderr(orth=False)
        for i in range(1, 1 + len(self.lut.cum_irf_stderr)):
            assert_almost_equal(np.round(stderr[i], 3),
                                self.lut.cum_irf_stderr[i - 1])

    def test_lr_effect_stderr(self):
        stderr = self.irf.lr_effect_stderr(orth=False)
        assert_almost_equal(np.round(stderr, 3), self.lut.lr_stderr)

    @pytest.mark.smoke
    def test_orth_lr_effect_stderr(self):
        self.irf.lr_effect_stderr(orth=True)


@pytest.mark.not_vetted
@pytest.mark.smoke
def test_var_trend():
    # GH#2271
    data = get_macrodata().view((float, 3), type=np.ndarray)

    with warnings.catch_warnings():
        warnings.simplefilter("ignore")

        model = VAR(data)
        results = model.fit(4, trend='c')
        results.irf(10)

    data_nc = data - data.mean(0)

    with warnings.catch_warnings():
        warnings.simplefilter("ignore")

        model_nc = VAR(data_nc)
        model_nc.fit(4, trend='nc')


@pytest.mark.not_vetted
def test_irf_trend():
    # GH#1636 test for irf with different trend
    # this is a rough comparison by adding trend or subtracting mean to data
    # to get similar AR coefficients and IRF
    data = get_macrodata().view((float, 3), type=np.ndarray)

    with warnings.catch_warnings():
        warnings.simplefilter("ignore")

        model = VAR(data)
        results = model.fit(4, trend='c')
        irf = results.irf(10)

    data_nc = data - data.mean(0)

    with warnings.catch_warnings():
        warnings.simplefilter("ignore")

        model_nc = VAR(data_nc)
        results_nc = model_nc.fit(4, trend='nc')
        irf_nc = results_nc.irf(10)

    assert_allclose(irf_nc.stderr()[1:4],
                    irf.stderr()[1:4],
                    rtol=0.01)

    trend = 1e-3 * np.arange(len(data)) / (len(data) - 1)
    # for pandas version, currently not used, if data is a pd.DataFrame
    # data_t = pd.DataFrame(data.values + trend[:, None],
    #                       index=data.index, columns=data.columns)
    data_t = data + trend[:, None]

    with warnings.catch_warnings():
        warnings.simplefilter("ignore")

        model_t = VAR(data_t)
        results_t = model_t.fit(4, trend='ct')
        irf_t = results_t.irf(10)

    assert_allclose(irf_t.stderr()[1:4],
                    irf.stderr()[1:4],
                    rtol=0.03)


def test_get_trendorder():
    results = {'c': 1,
               'nc': 0,
               'ct': 2,
               'ctt': 3}
    for t, trendorder in results.items():
        assert util.get_trendorder(t) == trendorder


def test_var_invalid_trend_rasies():
    # GH#2271
    data = get_macrodata().view((float, 3), type=np.ndarray)

    model = VAR(data)
    with pytest.raises(ValueError):
        model.fit(4, trend='t')


# ----------------------------------------------------------------
# Issue-Specific Regression Tests

def test_cov_params_wrapping():
    # GH#4463 (not the main issue) test that:
    # a) res.cov_params doesn't raise and
    # b) that the wrapping gets the order of the param index levels right
    data = sm.datasets.macrodata.load_pandas().data
    endog = data[['realgdp', 'realcons', 'realinv']].diff().iloc[1:]
    model = VAR(endog)
    res = model.fit(3)

    cp = res.cov_params
    z = res.endog_lagged
    v = scipy.linalg.inv(np.dot(z.T, z))
    v = pd.DataFrame(v, index=res.params.index, columns=res.params.index)
    for eq1 in res.sigma_u.index:
        for eq2 in res.sigma_u.index:
            subdf = cp.loc[(slice(None), eq1), (slice(None), eq2)]
            expected = res.sigma_u.loc[eq1, eq2] * v
            # unfortunately subdf comes back with a MultiIndex constant in
            # its second level, so we have to compare values instead of frames.
            assert (expected.values == subdf.values).all()


def test_var_constant():
    # GH#2043 if one of the variables in a VAR is constant --> singularity
    index = pd.date_range('now', periods=5, freq='D')
    # TODO: remove the index since it is irrelevant to this test?
    data = np.array([[2., 2.],
                     [1, 2.],
                     [1, 2.],
                     [1, 2.],
                     [1., 2.]])
    df = pd.DataFrame(data, index=index)

    model = VAR(df)
    with pytest.raises(ValueError):
        model.fit(1)


def test_var_process_mean():
    # GH#4442, VARProcess.mean should be well-defined iff there is
    # a constant term and no other trend/exog terms
    data = get_macrodata().view((float, 3), type=np.ndarray)
    data -= data.mean(axis=0)

    np.random.seed(4719)
    intercept = np.random.randn(data.shape[1])
    data += intercept.reshape(1, -1)

    model = VAR(data)

    res = model.fit(trend="c")
    assert res.k_trend == 1
    assert not hasattr(model, "k_trend")

    assert_allclose(intercept, res.mean(), rtol=1e-3)
    # TODO: It would be nice to get higher precision than this

    for trend in ["nc", "ct"]:
        res = model.fit(trend=trend)
        with pytest.raises(NotImplementedError):
            res.mean()

    exog = np.zeros((len(data), 3))
    exog[::4, 0] = 1
    exog[1::4, 1] = 1
    exog[2::4, 2] = 1

    model = VAR(endog=data, exog=exog)
    res = model.fit(trend="c")
    with pytest.raises(NotImplementedError):
        res.mean()

    res = model.fit(trend="nc")
    with pytest.raises(NotImplementedError):
        res.mean()
